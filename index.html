<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>æ™ºèƒ½æœ‰å£°ä¹¦ç”»æœ¬ç€è‰²å™¨ï¼ˆå¸¦åº”ç”¨æŒ‰é’®ï¼‰</title>
  <style>
    body {
      font-family: "Microsoft YaHei", sans-serif;
      max-width: 900px;
      margin: 20px auto;
      padding: 20px;
      background-color: #ffffff;
      color: #333333;
    }
    h1 { text-align: center; color: #2c3e50; }
    textarea {
      width: 100%; height: 220px; padding: 12px;
      font-size: 16px; border: 1px solid #ccc;
      border-radius: 6px; margin-bottom: 15px;
      font-family: inherit; background: #fff;
      resize: vertical;
    }
    .controls {
      display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;
    }
    button {
      padding: 9px 16px; background: #2c3e50; color: white;
      border: none; border-radius: 4px; cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #1a252f; }
    .btn-apply { background: #27ae60; }
    .btn-apply:hover { background: #219653; }
    .btn-merge { background: #8E44AD; }
    .btn-merge:hover { background: #7D3C98; }
    #roleInput {
      padding: 9px; font-size: 14px; border: 1px solid #999;
      border-radius: 4px; flex: 1; min-width: 150px;
    }
    #output {
      width: 100%; min-height: 250px; padding: 15px;
      background: #fff; border: 1px solid #ddd;
      border-radius: 6px; line-height: 1.6;
      white-space: pre-wrap; overflow-wrap: break-word;
      font-family: inherit; font-size: 16px;
    }
    .role-legend {
      margin-top: 20px; padding: 15px;
      background: #f8f9fa; border-radius: 6px;
      border: 1px solid #eee;
    }
    .role-item {
      display: flex; align-items: center;
      margin-bottom: 12px; padding: 6px 0;
    }
    .color-box {
      width: 24px; height: 24px;
      border-radius: 4px;
      margin-right: 10px;
      border: 1px solid #aaa;
      cursor: pointer;
    }
    .role-name {
      font-weight: bold;
      flex: 1;
    }
    .color-input {
      width: 80px;
      height: 30px;
      padding: 0 8px;
      border: 1px solid #999;
      border-radius: 4px;
      font-size: 13px;
    }
    .action-cell {
      display: flex; align-items: center;
      margin-left: 10px;
    }
    .apply-btn {
      margin-left: 8px;
      padding: 4px 10px;
      font-size: 12px;
    }
    select.merge-select {
      font-size: 13px; padding: 4px 6px;
      border: 1px solid #999; border-radius: 3px;
      margin: 0 6px;
    }
  </style>
</head>
<body>
  <h1>ğŸ¨ æ™ºèƒ½æœ‰å£°ä¹¦ç”»æœ¬ç€è‰²å™¨</h1>
  <p>æ”¯æŒè§’è‰²åˆå¹¶ã€è‡ªå®šä¹‰é¢œè‰²ï¼Œä¿®æ”¹åè¯·ç‚¹å‡»â€œåº”ç”¨â€ç”Ÿæ•ˆã€‚</p>

  <textarea id="input" placeholder="ä¾‹å¦‚ï¼š
å°æ˜ï¼šä½ å¥½ï¼
ã€å°æ˜ã€‘ä»Šå¤©çœŸå¼€å¿ƒã€‚
å°çº¢ï¼šæˆ‘ä»¬å»ç©å§ï¼
æ—ç™½ï¼šé˜³å…‰æ˜åªšã€‚
"></textarea>

  <div class="controls">
    <button onclick="autoHighlight()">æ™ºèƒ½è‡ªåŠ¨ç€è‰²</button>
    <input type="text" id="roleInput" placeholder="æ‰‹åŠ¨æŒ‡å®šè§’è‰²å" />
    <button onclick="manualHighlight()">æ‰‹åŠ¨ç€è‰²é€‰ä¸­æ–‡æœ¬</button>
    <button id="copyBtn" onclick="copyResult()">å¤åˆ¶ç»“æœï¼ˆä¿ç•™æ ¼å¼ï¼‰</button>
  </div>

  <h3>ç€è‰²é¢„è§ˆï¼š</h3>
  <div id="output"></div>

  <div class="role-legend" id="legend">
    <div style="display:flex; justify-content:space-between; margin-bottom:12px; align-items:center;">
      <strong>è§’è‰²é¢œè‰²ç®¡ç†ï¼ˆä¿®æ”¹åè¯·ç‚¹å‡»â€œåº”ç”¨â€ï¼‰</strong>
      <div>
        <button class="btn-merge" onclick="applyRoleMerge()">âœ“ åº”ç”¨è§’è‰²åˆå¹¶</button>
        <button class="btn-apply" onclick="applyAllColorChanges()" style="margin-left:8px;">âœ“ åº”ç”¨æ‰€æœ‰é¢œè‰²</button>
      </div>
    </div>
    <div id="roleList"></div>
  </div>

  <script>
    let roleColors = { "æ—ç™½": "#555555" };
    let roleMapping = {};
    // ä¸´æ—¶å­˜å‚¨ç”¨æˆ·ä¿®æ”¹çš„é¢œè‰²ï¼ˆæœªåº”ç”¨ï¼‰
    let pendingColorChanges = {};

    const defaultDeepColors = [
      "#C62828", "#1565C0", "#2E7D32", "#5D4037",
      "#6A1B9A", "#004D40", "#BF360C", "#3E2723",
      "#880E4F", "#01579B", "#33691E", "#AD1457"
    ];

    function cleanRoleName(role) {
      return role.trim()
        .replace(/^ã€|ã€‘$/g, '')
        .replace(/^ã€Œ|ã€$/g, '')
        .replace(/^"|"$/g, '')
        .replace(/^â€œ|â€$/g, '')
        .replace(/\s+/g, ' ');
    }

    function getRoleColor(role) {
      const clean = cleanRoleName(role);
      if (roleColors[clean]) return roleColors[clean];
      const color = defaultDeepColors[Object.keys(roleColors).length % defaultDeepColors.length];
      roleColors[clean] = color;
      return color;
    }

    function updateLegend() {
      const list = document.getElementById("roleList");
      const roles = Object.keys(roleColors);
      list.innerHTML = "";

      if (roles.length === 0) {
        list.innerHTML = "<p>æš‚æ— è§’è‰²ã€‚</p>";
        return;
      }

      roles.forEach(role => {
        const currentColor = roleColors[role] || "#000000";
        // æ˜¾ç¤ºå½“å‰å·²åº”ç”¨çš„é¢œè‰²ï¼ˆä¸æ˜¯ pendingï¼‰
        const displayColor = pendingColorChanges[role] !== undefined ? pendingColorChanges[role] : currentColor;

        const div = document.createElement("div");
        div.className = "role-item";
        div.innerHTML = `
          <input type="color" class="color-box" value="${displayColor}" data-role="${role}">
          <div class="role-name">${role}</div>
          <input type="text" class="color-input" value="${displayColor}" data-role="${role}" maxlength="7">
          <div class="action-cell">
            <button class="apply-btn btn-apply" data-role="${role}" onclick="applyColorForRole('${role}')">åº”ç”¨</button>
            <div style="margin-left:12px;">åˆå¹¶åˆ°ï¼š
              <select class="merge-select" data-source="${role}">
                <option value="">â€” é€‰æ‹© â€”</option>
                ${roles.filter(r => r !== role).map(r => 
                  `<option value="${r}">${r}</option>`
                ).join('')}
              </select>
            </div>
          </div>
        `;
        list.appendChild(div);

        // ç»‘å®šè¾“å…¥äº‹ä»¶ï¼ˆä»…æ›´æ–° pendingï¼Œä¸ç«‹å³ç”Ÿæ•ˆï¼‰
        const colorBox = div.querySelector(".color-box");
        const colorInput = div.querySelector(".color-input");

        colorBox.addEventListener("input", function() {
          pendingColorChanges[role] = this.value;
          colorInput.value = this.value;
        });

        colorInput.addEventListener("input", function() {
          let val = this.value.trim();
          if (val && !val.startsWith("#")) val = "#" + val;
          if (/^#[0-9A-F]{6}$/i.test(val)) {
            pendingColorChanges[role] = val;
            colorBox.value = val;
          }
        });
      });
    }

    // åº”ç”¨å•ä¸ªè§’è‰²çš„é¢œè‰²
    function applyColorForRole(role) {
      if (pendingColorChanges[role] !== undefined) {
        roleColors[role] = pendingColorChanges[role];
        delete pendingColorChanges[role];
        rerenderOutput();
        // æ›´æ–°UIæ˜¾ç¤ºå·²åº”ç”¨çŠ¶æ€ï¼ˆç§»é™¤ pending æ ‡è®°ï¼‰
        updateLegend();
        console.log(`âœ… å·²åº”ç”¨é¢œè‰²åˆ°è§’è‰²: ${role}`);
      }
    }

    // ä¸€é”®åº”ç”¨æ‰€æœ‰å¾…å®šé¢œè‰²
    function applyAllColorChanges() {
      let count = 0;
      for (const role in pendingColorChanges) {
        roleColors[role] = pendingColorChanges[role];
        count++;
      }
      if (count > 0) {
        pendingColorChanges = {};
        rerenderOutput();
        updateLegend();
        alert(`âœ… å·²åº”ç”¨ ${count} ä¸ªè§’è‰²çš„é¢œè‰²ï¼`);
      } else {
        alert("â„¹ï¸ æ²¡æœ‰æœªåº”ç”¨çš„é¢œè‰²ä¿®æ”¹ã€‚");
      }
    }

    function applyRoleMerge() {
      const selects = document.querySelectorAll(".merge-select");
      let merged = false;
      for (const sel of selects) {
        const source = sel.dataset.source;
        const target = sel.value;
        if (target) {
          roleMapping[source] = target;
          roleColors[source] = roleColors[target]; // ç»§æ‰¿é¢œè‰²
          merged = true;
        }
      }
      if (merged) {
        rerenderOutput();
        updateLegend();
        alert("âœ… è§’è‰²åˆå¹¶å®Œæˆï¼");
      } else {
        alert("â„¹ï¸ æœªé€‰æ‹©åˆå¹¶é¡¹ã€‚");
      }
    }

    function rerenderOutput() {
      const text = document.getElementById("input").value;
      if (!text.trim()) return;

      const blocks = parseDialogue(text);
      let html = "";

      for (const block of blocks) {
        if (block.type === 'dialogue') {
          let stdRole = cleanRoleName(block.role);
          if (roleMapping[stdRole]) stdRole = roleMapping[stdRole];
          const color = roleColors[stdRole] || getRoleColor(stdRole);
          const safeContent = escapeHtml(block.content).replace(/\n/g, "<br>");
          html += `<span style="color:${color};">${safeContent}</span>\n`;
        } else {
          html += `<span>${escapeHtml(block.content).replace(/\n/g, "<br>")}</span>\n`;
        }
      }

      document.getElementById("output").innerHTML = html;
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "<")
        .replace(/>/g, ">")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // ===== æ™ºèƒ½è§£æé€»è¾‘ =====
    function parseDialogue(text) {
      const lines = text.split('\n');
      const result = [];
      let i = 0;

      while (i < lines.length) {
        const rawLine = lines[i];
        const line = rawLine.trim();
        if (!line) {
          result.push({ type: 'text', content: rawLine });
          i++; continue;
        }

        let match = line.match(/^([ã€ã€Œ"â€œ]?[\u4e00-\u9fa5a-zA-Z0-9_\s]+?[ã€‘ã€"â€]?)[ï¼š:\sã€€]+(.*)$/);
        if (match && match[1].replace(/[ã€ã€‘ã€Œã€"â€œâ€]/g, '').trim().length <= 12) {
          const roleTag = match[1];
          const roleClean = cleanRoleName(roleTag);
          let dialogue = match[2];
          let contentLines = [roleTag + 'ï¼š' + dialogue];
          i++;
          while (i < lines.length && /^\s/.test(lines[i]) && lines[i].trim()) {
            contentLines.push(lines[i]); i++;
          }
          result.push({ type: 'dialogue', role: roleClean, content: contentLines.join('\n') });
          continue;
        }

        match = line.match(/^([\u4e00-\u9fa5a-zA-Z0-9_]{1,12})[ï¼š:\sã€€]+(.+)$/);
        if (match) {
          const role = match[1];
          let dialogue = match[2];
          let contentLines = [role + 'ï¼š' + dialogue];
          i++;
          while (i < lines.length && /^\s/.test(lines[i]) && lines[i].trim()) {
            contentLines.push(lines[i]); i++;
          }
          result.push({ type: 'dialogue', role: role, content: contentLines.join('\n') });
          continue;
        }

        result.push({ type: 'text', content: rawLine });
        i++;
      }
      return result;
    }

    function autoHighlight() {
      const text = document.getElementById("input").value;
      if (!text.trim()) return;

      // é‡ç½®çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
      roleMapping = {};
      pendingColorChanges = {};

      const blocks = parseDialogue(text);
      roleColors = { "æ—ç™½": "#555555" };

      let html = "";
      for (const block of blocks) {
        if (block.type === 'dialogue') {
          const color = getRoleColor(block.role);
          const safeContent = escapeHtml(block.content).replace(/\n/g, "<br>");
          html += `<span style="color:${color};">${safeContent}</span>\n`;
        } else {
          html += `<span>${escapeHtml(block.content).replace(/\n/g, "<br>")}</span>\n`;
        }
      }

      document.getElementById("output").innerHTML = html;
      updateLegend();
    }

    function manualHighlight() {
      const role = document.getElementById("roleInput").value.trim();
      if (!role) return alert("è¯·è¾“å…¥è§’è‰²å");
      const input = document.getElementById("input");
      const start = input.selectionStart;
      const end = input.selectionEnd;
      const fullText = input.value;
      if (start === end) return alert("è¯·å…ˆé€‰ä¸­ä¸€æ®µæ–‡æœ¬");

      const selected = fullText.substring(start, end);
      const color = getRoleColor(role);
      const safeSelected = escapeHtml(selected);
      const before = escapeHtml(fullText.substring(0, start));
      const after = escapeHtml(fullText.substring(end));

      document.getElementById("output").innerHTML = 
        (before + `<span style="color:${color};">${safeSelected}</span>` + after)
        .replace(/\n/g, "<br>");

      updateLegend();
    }

    function copyResult() {
      const outputDiv = document.getElementById("output");
      if (!outputDiv.innerHTML.trim()) return alert("è¯·å…ˆç”Ÿæˆç»“æœ");

      const pre = document.createElement("pre");
      pre.style.fontFamily = '"Microsoft YaHei", sans-serif';
      pre.style.fontSize = "16px";
      pre.style.whiteSpace = "pre";
      pre.style.margin = "0"; pre.style.padding = "0";
      pre.innerHTML = outputDiv.innerHTML;
      pre.style.position = "fixed"; pre.style.left = "-9999px";
      document.body.appendChild(pre);

      const range = document.createRange();
      range.selectNode(pre);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);

      let success = false;
      try { success = document.execCommand("copy"); } catch (e) {}

      window.getSelection().removeAllRanges();
      document.body.removeChild(pre);

      if (success) {
        alert("âœ… å·²å¤åˆ¶ï¼é¢œè‰²ã€æ¢è¡Œã€ç¼©è¿›å·²ä¿ç•™ã€‚");
      } else {
        alert("âš ï¸ è¯·æ‰‹åŠ¨å¤åˆ¶é¢„è§ˆåŒºå†…å®¹ã€‚");
      }
    }

    updateLegend();
  </script>
</body>
</html>